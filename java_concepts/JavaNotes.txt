
1. **** .equals() and ==, obj1.equals(obj2) compares the instance whee as == compares the value.
        Obj obj1=new Obj(23);
        Obj obj2=new Obj(23);
        obj1.equals(obj2) is false, ob1==obj2 is true

hashCode(obj) gives he hash code value to store any object.
When .equals() is true, hashCode values are same always
When .equals() is false, need not mean hashCode() is different

2. Inheritance: Multiple inheritanc is not supported.
3. Method Overloading and Method Overriding
4. Interface variables are by default public static final, private cannt be declared.
5. All methods of interface must be implemeneted in subclass.
6. Implements interface.
7. Interface methods can have default impomentation from java 8.
8. Interface example hashmap implements map.
9. Abstract Class might not have abstract methods, but abstract methods can only be declared in abstract Class.
10. Abstract class cannot be instantiated.
11. Abstract class when to use? Abstract class methods can have different visibility unlike inteface.
12. Constructor - If you provide a constructor then no argument constructor which is by default constructor get overriden.
Then no argument constructor cannot be called after defining 1 argument constructor.
13. super() calls parent class constructor. super() mustt be called in the first line of constructor.
14.*** Callig another constrcutor in same class using "this".
     class Animal{

        public Animal(){
            this("hello")
        }

        public Animal(str:string){
            sysout(str)
        }
     }
15. Without se of super also by befault parent class construct gets called.
16. Polymorphsim:
            Animal animal=new Dog();
            Animal animal2=new Cat();
            animal can only use methods defined in dog and animal2 can do for Cat.
17. *** intancOf Opertaor: To check object type is of a particular class. The object will be instance of 
    its parent also.
        Object obj=new Object();
        obj instanceOf(Object.class)
18. Coupling: Change in one class causes change in other classes also.
19. Cohesive: How related responsibilities of a class methods are. More cohesive more relted.
20. Classes should be highly cohesive.
21. Encapsulation: Hiding the implmentation of a class behind an interface.


        Scorer score=new Scorer();
        score.four();// no one knows implmenetation behind 
        score.six()// no one knows implmenetation
22. Inner class and Static Inner class: STatic Inner class contans non static members also
23.**** You need no to make Outer class object instance to create inner class instance in static Inner class.
24.**** Inner classes can access the variables of the outer class, including the private instance variables.
    Unlike the non-static nested classes, the static nested class cannot directly access the instance variables
    or methods of the outer class. They can access them by referring to an object of a class.
25. Anonymous class:Comparator

        Animal anm=new Animal({
            void bak(){
                sysout("bow bow")
            }
        })

26. Modifiers: Default, public, protected, private
27. Default: Accessible in same package only.
28. Private: Only accessible in class, not even subclasses
29: Protected : Available in subclass
30. In a same package class: Default, publc, protetced are accessible.
31. In different package only public is available..
32. Final Variable: Extending final class not possible.
33. String, Integer classesa are final, bcoz they are immutable .
34. Final methods cannot be overriden. Useful where parent wants to keep method constant.
35. Final variable: Fixed vaue.
36. If a agument is final, it cannot be modified.
37. Static creates class level memebers.
38. Each instance of class will not have unique instance that static variable. 
39. Static methods only allw static variables, not instance variables.
40. Local variables defined in amethod cannot be static.
41. The assignment statement always returns the same value back.
    if(isTrue=true){}
    This condition is true becoz assignment returns value true.\
42. Infinite loop: for(;;){}
43. break outer, will break out of outer loop which is lopp inside loop case.
44. toString() is a method of Object class. Which you do sysout(obj) it return toString() value of a object.
    We can override toSTring() method if we want to print values. So when you print array, it prints address in
    string format.
    Arrays.toString(array) // will print values in array.
    Arrays.deepToString(). // for 2d
45. Have unique id for different exceptions.
46. Finally block in try catch is mainly used for any cleanup that needs to be done, like close connection etc.
47. Even if there is a return statement in catch, still finally will be executed. Finally will not be executed,
only when there is another catch inside finally or JVM crashes.
48. try blck should always have a catch or finally or both. 
49. Exceptions are of 2 types: Checked and unchecked exceptions.
50 Checked exceptions are used when you want calling method of that method to handle exception, where as when you
don't want caling method to handle exceptions then you use unchecked exception.
51. Extending Exception : Checked Exception, Entending RuntimeException : Unchecked Exception.
52. Errors cannot be handled by programmer, exceptions are.
53. We need to add "throws Exception" in our methods if we are throwing checked exception. The calling method needs to
either handle the try catch, or will have to add "throws Exception".
54. Order of exeption must always be from specific to generic in catch. Otherwise compilation error.
55. We can add multiple exception in one catch(Exceotion1 | Exception2){}
56. Intger array, is initialised with 0, boolean with false
57. Array of objects is iniialised withnull values.
58. .equals() also work for array, if elements are equal.
59. Enum is used when a specific type can have fixed set of values.
60. Enum can have variable and methods.
61. Variable arguments:  It should always be last parameter if variable.

    public void sum(int... numbers){
        // internally treated like an array.
    }

    I can call this method with different number of arguments.
62. Objects can also be variable arguments.
63. Asserts: assert(age>10): Basic constraints, it is not a proper validation.
64. Garbage collection happens automatically in java.
65. static initializer loads / runs when a class is loaded.
     static{
        //
     }
69. Instance initializer loads whe a object is created.
{
    //
}

70. Serialize: Convert object to internal object representation.
    Deserialize: Convert some internal object representation to object.
71. ObjectOutputSTrean.writeObject() // Serialize
    ObjectOutputSTrean.readObject() // deSerialize
72. To serialize, a class should implement Serializable.
73. Variables declared "transient" are not Serializable.
74. Since static variables are part of the class and not obejct. they are not serializable.
75. Collection interface: Set, List, Queue
76. Map does not extend Collection interface.
77. Arrayist, LinkedList and vector implment List Intreface.
78. Insertion and deletion in LinkedList is faster than arraylist.
79. LinkedList implements both queue and list interface.
80. Set interface doesnot allow duplication.
81. ArrayList insertion average time is O(n) while for hastset it is O(1).
82. SortedSet keeps elements sorted.
83. HashSet does not gurantee order of insertion whereas LinkedHashSet do.
84. TreeSet is sorted, hence no order of inserion and no duplicates.